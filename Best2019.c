#pragma config(Sensor, dgtl2,  irLeft,         sensorDigitalIn)
#pragma config(Sensor, dgtl3,  irRight,        sensorDigitalIn)
#pragma config(Motor,  port2,           motorLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           motorRP,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           motorRight,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int getIrReading(tSensors irReceiverPin)
{
		wait1Msec(1);
		int ir = SensorValue[irReceiverPin];
		wait1Msec(1);
		return ir;
}

task main()
{
	while (true)
	{

		//Rack and Pinion Code
		if(vexRT[Btn5U] == 1)
		{
			motor[motorRP] = -50;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[motorRP] = 25;
		}
		else{
			motor[motorRP] = 0;
		}
		//Servo Code
		if(vexRT[Btn7U] == 1){
			motor[servo] = -128;
		}
		else if(vexRT[Btn7D] == 1){
			motor[servo] = 128;
		}


		// Joystick to Motor Drive
		motor[motorLeft] = vexRT[Ch3];
		motor[motorRight] = vexRT[Ch2];

		//Joystick to Motor Parabolic Drive
		/*if (vexRT[Ch3] > 0)
		{
			motor[motorLeft] = (vexRT[Ch3]) * (vexRT[Ch3]) * 100;
		}
		else if (vexRT[Ch3] < 0)
		{
			motor[motorLeft] = -1 * (vexRT[Ch3]) * (vexRT[Ch3]) * 100;
		}

		if (vexRT[Ch2] > 0)
		{
			motor[motorRight] = (vexRT[Ch2]) * (vexRT[Ch2]) * 100;
		}
		else if (vexRT[Ch2] < 0)
		{
			motor[motorRight] = -1 * (vexRT[Ch2]) * (vexRT[Ch2]) * 100;
		}*/

		// Drive with Channel 3 Forward and Backwards, Channel 1 Left and Right
		/*float straightChannel = vexRT[Ch3];
		float turningChannel = vexRT[Ch1];
		float forwards = (straightChannel) * (straightChannel) * 100;
		float backwards = -1 * (straightChannel) * (straightChannel) * 100;
		float turning = (turningChannel) * (turningChannel) * 50;

		if (vexRT[Ch3] > 0 && turningChannel > 0)
		{
			motor[motorLeft] = 	forwards;
			motor[motorRight] = turning;
		}
		else if (vexRT[Ch3] > 0 && turningChannel < 0)
		{
			motor[motorLeft] = 	turning;
			motor[motorRight] = forwards;
		}
		else if (straightChannel < 0 && turningChannel > 0)
		{
			motor[motorLeft] = 	backwards;
			motor[motorRight] = turning;
		}
		else if (straightChannel < 0 && turningChannel < 0)
		{
			motor[motorLeft] = 	turning;
			motor[motorRight] = backwards;
		}
		else if (straightChannel > 0)
		{
			motor[motorLeft] = forwards;
			motor[motorRight] = forwards;
		}
		else if (straightChannel < 0)
		{
			motor[motorLeft] = 	backwards;
			motor[motorRight] = backwards;
		}*/

		//toggle autonomous

		bool autoActive = false;

		if (vexRT[Btn8D] == 1 && autoActive == false)
		{
			autoActive = true;
		}

		//autonomous - 2 sensors

		int blackDetected = 1;
		int whiteDetected = 0;
		int forwardSpeed = 35;
		int turnSpeed = 30;


		while (autoActive)
		{
			if (getIrReading(irLeft) == blackDetected && getIrReading(irRight) == blackDetected)
			{
				motor[motorLeft] = forwardSpeed;
				motor[motorRight] = forwardSpeed;
			}
			else if (getIrReading(irLeft) == whiteDetected && getIrReading(irRight) == blackDetected)
			{
				motor[motorLeft] = -1 * turnSpeed;
				motor[motorRight] = turnSpeed;
			}
			else if (getIrReading(irRight) == whiteDetected && getIrReading(irLeft) == blackDetected)
			{
				motor[motorLeft] = turnSpeed;
				motor[motorRight] = -1 * turnSpeed;
			}

			if (vexRT[Btn8U] == 1)
			{
				autoActive = false;
			}
		}

		//autonomous - 1 sensor

		/*bool direction = false;
		bool hasSeenWhite = false;

		while (autoActive)
		{
			if(direction){
				motor[motorLeft] = 50;
				motor[motorRight] = 20;
			}
			else{
				motor[motorLeft] = 20;
				motor[motorRight] = 50;
			}

			if(getIrReading(irSensor)==0){
				hasSeenWhite = true;
			}


			if (getIrReading(irSensor) == 1) {
				if(hasSeenWhite){
					direction = !direction;
					hasSeenWhite = false;
				}
			}*/
	}
}
