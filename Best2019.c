#pragma config(Sensor, dgtl2,  irLeft,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  irRight,        sensorDigitalIn)
#pragma config(Motor,  port2,           motorLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           motorRP,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motorRight,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Global Variables
float gear = 1;
int direction = true;
int prev6D = false;
int prev7U = false;
int prev7L = false;
int servoPos = 128;
int servoAutoClose = 2000; //Milliseconds
int getIrReading(tSensors irReceiverPin)
{
	wait1Msec(1);
	int ir = SensorValue[irReceiverPin];
	wait1Msec(1);
	return ir;
}





task main()
{
	//Setup Stuff
	motor[servo] = 128; //Set servo to correct start position
	while (true)
	{

		//Rack and Pinion Code
		if(vexRT[Btn5U] == 1)
			motor[motorRP] = -100;//Up Speed
		else if(vexRT[Btn5D] == 1)
			motor[motorRP] = 75;//Down Speed
		else
			motor[motorRP] = -25;//Default (Brake)


		// Servo Code
		if (vexRT[Btn7U] != prev7U){//Detect button change
			prev7U = vexRT[Btn7U];
			if(vexRT[Btn7U] == 1)//Only run on rising edge (aka press, not release)
				servoPos = (servoPos == 128) ? -50 : 128;
			motor[servo] = servoPos;
			clearTimer(timer1);
		}
		//Automatically close hatch after too long
		if(time1[timer1] >= servoAutoClose){
			servoPos = 128;
			motor[servo] = servoPos;
		}

		// GearBox

		if (vexRT[Btn8U] == 1)
			gear = 1;
		else if (vexRT[Btn8L] == 1)
			gear = 0.75;
		else if (vexRT[Btn8R] == 1)
			gear = 0.50;
		else if (vexRT[Btn8D] == 1)
			gear = 0.25;

		// Direction

		if (vexRT[Btn6D] != prev6D){
			prev6D = vexRT[Btn6D];
			if(vexRT[Btn6D] == 1)
				direction = (direction == 1) ? -1 : 1;
		}

		// Drive
		if(vexRT[Btn6U]==1){
			motor[motorLeft] = -50;
			motor[motorRight] = 50;
		}
		else{
			if(direction == 1){
				motor[motorLeft] = gear * vexRT[Ch3];
				motor[motorRight] = -gear * vexRT[Ch2];
			}
			else{
				motor[motorRight] = gear * vexRT[Ch3];
				motor[motorLeft] = -gear * vexRT[Ch2];
			}
		}
		// Joystick to Motor Drive


		//Joystick to Motor Parabolic Drive
		/*if (vexRT[Ch3] > 0)
		{
		motor[motorLeft] = (vexRT[Ch3]) * (vexRT[Ch3]) * 100;
		}
		else if (vexRT[Ch3] < 0)
		{
		motor[motorLeft] = -1 * (vexRT[Ch3]) * (vexRT[Ch3]) * 100;
		}

		if (vexRT[Ch2] > 0)
		{
		motor[motorRight] = (vexRT[Ch2]) * (vexRT[Ch2]) * 100;
		}
		else if (vexRT[Ch2] < 0)
		{
		motor[motorRight] = -1 * (vexRT[Ch2]) * (vexRT[Ch2]) * 100;
		}*/

		// Drive with Channel 3 Forward and Backwards, Channel 1 Left and Right
		/*float straightChannel = vexRT[Ch3];
		float turningChannel = vexRT[Ch1];
		float forwards = (straightChannel) * (straightChannel) * 100;
		float backwards = -1 * (straightChannel) * (straightChannel) * 100;
		float turning = (turningChannel) * (turningChannel) * 50;

		if (straightChannel > 0 && turningChannel > 0)
		{
		motor[motorLeft] = 	forwards;
		motor[motorRight] = turning;
		}
		else if (straightChannel > 0 && turningChannel < 0)
		{
		motor[motorLeft] = 	turning;
		motor[motorRight] = forwards;
		}
		else if (straightChannel < 0 && turningChannel > 0)
		{
		motor[motorLeft] = 	backwards;
		motor[motorRight] = turning;
		}
		else if (straightChannel < 0 && turningChannel < 0)
		{
		motor[motorLeft] = 	turning;
		motor[motorRight] = backwards;
		}
		else if (straightChannel > 0)
		{
		motor[motorLeft] = forwards;
		motor[motorRight] = forwards;
		}
		else if (straightChannel < 0)
		{
		motor[motorLeft] = 	backwards;
		motor[motorRight] = backwards;
		}
		else
		{
		motor[motorLeft] = 0;
		motor[motorRight] = 0;
		}*/

		//toggle autonomous

		bool autoActive = false;

		if (vexRT[Btn7L] != prev7L)
		{
			if(vexRT[Btn7L] == 1)
				autoActive = true;
			prev7L = vexRT[Btn7L];
		}

		//autonomous - 2 sensors

		int blackDetected = 1;
		int whiteDetected = 0;
		int forwardSpeed = 70;
		int turnSpeed = 90;


		/*if (vexRT[Btn8R] == 1)
		{
		turnSpeed += 5;
		}

		if (vexRT[Btn8L] == 1)
		{
		turnSpeed -= 5;
		}

		if (vexRT[Btn7R] == 1)
		{
		forwardSpeed += 5;
		}

		if (vexRT[Btn7L] == 1)
		{
		forwardSpeed -= 5;
		}*/

		while (autoActive)
		{
			if (getIrReading(irLeft) == blackDetected && getIrReading(irRight) == blackDetected)
			{
				motor[motorLeft] = forwardSpeed;
				motor[motorRight] = -forwardSpeed;
			}
			else if (getIrReading(irLeft) == whiteDetected && getIrReading(irRight) == blackDetected)
			{
				motor[motorLeft] = 0.75 * turnSpeed;
				motor[motorRight] = turnSpeed;
			}
			else if (getIrReading(irRight) == whiteDetected && getIrReading(irLeft) == blackDetected)
			{
				motor[motorLeft] = -1 * turnSpeed;
				motor[motorRight] = -0.75 * turnSpeed;
			}
			else
			{
				motor[motorLeft] = -forwardSpeed;
				motor[motorRight] = forwardSpeed;
			}

			if (vexRT[Btn7L] != prev7L)
			{
				if(vexRT[Btn7L] == 1)
					autoActive = false;
				prev7L = vexRT[Btn7L];
			}
		}

		//autonomous - 1 sensor

		/*bool direction = false;
		bool hasSeenWhite = false;

		while (autoActive)
		{
		if(direction){
		motor[motorLeft] = 50;
		motor[motorRight] = 20;
		}
		else{
		motor[motorLeft] = 20;
		motor[motorRight] = 50;
		}

		if(getIrReading(irSensor)==0){
		hasSeenWhite = true;
		}


		if (getIrReading(irSensor) == 1) {
		if(hasSeenWhite){
		direction = !direction;
		hasSeenWhite = false;
		}
		}*/
	}
}
