#pragma config(Sensor, dgtl2,  irLeft,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  irRight,        sensorDigitalIn)
#pragma config(Sensor, dgtl6,  limitSwitch,    sensorTouch)
#pragma config(Motor,  port2,           motorLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           autoRelease,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           motorRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           motorRP,       tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Global Variables
float gear = 1;
int direction = true;
int prev6D = false;
int prev7U = false;
int prev6U = false;
int prev7L = false;
int servoPos = 128;
int servoAutoClose = 2000; //Milliseconds

int getIrReading(tSensors irReceiverPin)
{
	wait1Msec(1);
	int ir = SensorValue[irReceiverPin];
	wait1Msec(1);
	return ir;
}


task main()
{
	//Setup Stuff
	motor[servo] = 128; //Set servo to correct start position
	motor[autoRelease] = 128;
	while (true)
	{

		//Rack and Pinion Code
		if(vexRT[Btn5U] == 1)
			motor[motorRP] = -100;//Up Speed
		else if(vexRT[Btn5D] == 1)
			motor[motorRP] = 75;//Down Speed
		else
			motor[motorRP] = -25;//Default (Brake)


		// Servo Code
		if (vexRT[Btn7U] != prev7U || vexRT[Btn6U] != prev6U){//Detect button change
			prev7U = vexRT[Btn7U];
			prev6U = vexRT[Btn6U];
			if(vexRT[Btn7U] == 1 || vexRT[Btn6U] == 1)//Only run on rising edge (aka press, not release)
				servoPos = (servoPos == 128) ? -50 : 128;
			motor[servo] = servoPos;
			clearTimer(timer1);
		}

		//Automatically close hatch after too long
		if(time1[timer1] >= servoAutoClose){
			servoPos = 128;
			motor[servo] = servoPos;
		}

		// GearBox

		if (vexRT[Btn8U] == 1)
			gear = 1;
		else if (vexRT[Btn8R] == 1)
			gear = 0.50;

		// Direction

		if (vexRT[Btn6D] != prev6D){
			prev6D = vexRT[Btn6D];
			if(vexRT[Btn6D] == 1)
				direction = (direction == 1) ? -1 : 1;
		}

		// Drive
		if(vexRT[Btn6U]==1){

		}
		else{
			if(direction == 1){
				if (vexRT[Ch3] > 0)
					motor[motorLeft] = gear * 100 * (1 / (1 + pow(2.718, -((vexRT[Ch3]/8) - 6))));
				else if (vexRT[Ch3] < 0)
					motor[motorLeft] = -gear * 100 * (1 / (1 + pow(2.718, -((-vexRT[Ch3]/8) - 6))));
				else
					motor[motorLeft] = 0;
				
				if (vexRT[Ch2] > 0)
					motor[motorRight] = -gear * 100 * (1 / (1 + pow(2.718, -((vexRT[Ch2]/8) - 6))));
				else if (vexRT[Ch2] < 0)
					motor[motorRight] = gear * 100 * (1 / (1 + pow(2.718, -((-vexRT[Ch2]/8) - 6))));
				else
					motor[motorRight] = 0;
			}
			else{
				if (vexRT[Ch3] > 0)
					motor[motorRight] = gear * 100 * (1 / (1 + pow(2.718, -((vexRT[Ch3]/8) - 6))));
				else if (vexRT[Ch3] < 0)
					motor[motorRight] = -gear * 100 * (1 / (1 + pow(2.718, -((-vexRT[Ch3]/8) - 6))));
				else
					motor[motorRight] = 0;
				
				if (vexRT[Ch2] > 0)
					motor[motorLeft] = -gear * 100 * (1 / (1 + pow(2.718, -((vexRT[Ch2]/8) - 6))));
				else if (vexRT[Ch2] < 0)
					motor[motorLeft] = gear * 100 * (1 / (1 + pow(2.718, -((-vexRT[Ch2]/8) - 6))));
				else
					motor[motorLeft] = 0;

			}
		}

		//toggle autonomous

		bool autoActive = false;

		if (vexRT[Btn7L] != prev7L)
		{
			if(vexRT[Btn7L] == 1)
				autoActive = true;
			prev7L = vexRT[Btn7L];
		}

		//autonomous - 2 sensors

		int blackDetected = 1;
		int whiteDetected = 0;
		int limitPressed = 0;
		int forwardSpeed = 40;
		int turnSpeed = 60;
		if(time1[timer2] >= 5000)
				motor[autoRelease] = 128;

		while (autoActive)
		{
			if (SensorValue(limitSwitch) == limitPressed)
			{
				motor[motorLeft] = 0;
				motor[motorRight] = 0;
				motor[autoRelease] = -128;
				autoActive = false;
				clearTimer(timer2);
			}
			else
			{
				if (getIrReading(irLeft) == blackDetected && getIrReading(irRight) == blackDetected)
				{
					motor[motorLeft] = forwardSpeed;
					motor[motorRight] = -1.35 * forwardSpeed;
				}
				else if (getIrReading(irLeft) == whiteDetected && getIrReading(irRight) == blackDetected)
				{
					motor[motorLeft] = 1 * turnSpeed;
					motor[motorRight] = 0.75 * turnSpeed;
				}
				else if (getIrReading(irRight) == whiteDetected && getIrReading(irLeft) == blackDetected)
				{
					motor[motorLeft] = -0.75 * turnSpeed;
					motor[motorRight] = -1 * turnSpeed;
				}
				else
				{
					motor[motorLeft] = -forwardSpeed;
					motor[motorRight] = 1.35 * forwardSpeed;
				}
			}

			if (vexRT[Btn7L] != prev7L)
			{
				if(vexRT[Btn7L] == 1){
					autoActive = false;
					motor[autoRelease] = 128;
				}
				prev7L = vexRT[Btn7L];
			}
		}
	}
}
